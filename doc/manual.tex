\documentclass[11pt]{report}
\usepackage{graphicx}
\usepackage{abstract}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[breaklinks]{hyperref}
\usepackage{fancyvrb}
\usepackage{etoolbox}
\usepackage{amsmath}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{positioning, fit}
\usepackage{unison}
\usepackage[left=3cm, right=3cm]{geometry}
\usepackage[adobe-utopia]{mathdesign}

\setcounter{secnumdepth}{2}

\title{The Unison Manual}

\author{Roberto Castañeda Lozano}

\date{}

\renewcommand{\abstractname}{}
\renewcommand{\absnamepos}{empty}

\begin{document}

\maketitle

\setcounter{tocdepth}{2}
\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

You are reading the manual of \href{http://unison-code.github.io/}{Unison}: a
simple, flexible, and potentially optimal open-source tool that performs
integrated \href{https://en.wikipedia.org/wiki/Register_allocation}{register
  allocation} and
\href{https://en.wikipedia.org/wiki/Instruction_scheduling}{instruction
  scheduling} using
\href{https://en.wikipedia.org/wiki/Constraint_programming}{constraint
  programming}.

Unison can be used as an alternative or as a complement to the algorithms
applied by standard compilers such as \href{https://gcc.gnu.org/}{GCC} and
\href{http://llvm.org/}{LLVM}.
%
Unison is particularly easy to integrate with the latter as a driver is already
available (see Chapter~\ref{sec:llvm-integration} for details).

This manual is divided into two main parts: Part~\ref{part:using-unison}
(Chapters~\ref{sec:license-contact-and-acknowledgments}
to~\ref{sec:llvm-integration}) is devoted to the use of Unison, while
Part~\ref{part:developing-and-extending-unison} (Chapters~\ref{sec:architecture}
to~\ref{sec:target-description}) deals with its development and extension.

Chapter~\ref{sec:license-contact-and-acknowledgments} discusses licensing
aspects and provides contact information.
%
Chapter~\ref{sec:getting-started} contains instructions to download, build,
install, and test Unison.
%
Chapter~\ref{sec:llvm-integration} describes how to use the LLVM driver.

Chapter~\ref{sec:architecture} outlines the architecture of Unison.
%
Chapter~\ref{sec:unison-ir} describes the intermediate representation
(\emph{Unison IR}).
%
Chapter~\ref{sec:constraint-model} formulates the constraint model that lies at
the core of the Unison approach.
%
Chapter~\ref{sec:target-description} provides information about how processors
are described in Unison.

Appendix~\ref{sec:further-reading} provides references for further reading and
other sources of documentation.

\part{Using Unison}
\label{part:using-unison}

\chapter{License, Contact, and Acknowledgments}%
\label{sec:license-contact-and-acknowledgments}

Unison is developed at the \href{https://www.sics.se/}{Swedish Institute of
  Computer Science} in collaboration with \href{https://www.kth.se/en}{KTH Royal
  Institute of Technology} in Stockholm, Sweden.

Unison and the Unison Driver for LLVM are released under the BSD3 open-source
license:

\fvset{fontsize=\footnotesize}
\begin{center}
\BVerbatimInput{verbatim/LICENSE}
\end{center}

Unison includes code from the following projects:

\begin{itemize}
\item \href{https://hackage.haskell.org/package/Graphalyze}{Graphalyze} (in some
  graph algorithms of \texttt{unison} package).
  %
  The code is licensed under
  \href{https://hackage.haskell.org/package/Graphalyze/src/LICENSE}{BSD2}.
\item Erik Ekström's
  \href{https://www.sics.se/\%7ercas/teaching/ErikEkstrom_2015.pdf}{master's
    thesis} (in parts of the presolver).
  %
  The code is licensed under BSD3 but the copyright is held by Erik Ekström.

\item Mikael Almgren's
  \href{https://www.sics.se/\%7ercas/teaching/MikaelAlmgren_2015.pdf}{master's
    thesis} (in parts of the presolver).
  %
  The code is licensed under BSD3 but the copyright is held by Mikael Almgren.
\end{itemize}

The Unison Driver is built on top of the LLVM Compiler Infrastructure which is
licensed under the University of Illinois/NCSA Open Source License, see
\href{http://llvm.org/}{the LLVM website} for details.

Furthermore, Unison makes extensive use of other open-source components,
including:

\begin{itemize}
\item \href{http://www.gecode.org/}{Gecode}
\item \href{https://www.qt.io/}{Qt}
\item \href{http://www.graphviz.org/}{Graphviz}
\item \href{https://www.haskell.org/platform/}{Haskell Platform}
\item Various Haskell packages (see the \texttt{Build-Depends} field in
  \href{https://github.com/unison-code/unison/blob/master/src/unison/unison.cabal}{this}
  and
  \href{https://github.com/unison-code/unison/blob/master/src/unison-specsgen/unison-specsgen.cabal}{this}
  package descriptions)
\end{itemize}

For further license detail on these components, please check their websites.

Unison is designed, developed, and maintained by

\begin{itemize}
\item Roberto Castañeda Lozano (\href{mailto:rcas@sics.se}{rcas@sics.se})
\item Mats Carlsson (\href{mailto:matsc@sics.se}{matsc@sics.se})
\item Gabriel Hjort Blindell (\href{mailto:ghb@kth.se}{ghb@kth.se})
\item Christian Schulte (\href{mailto:cschulte@kth.se}{cschulte@kth.se})
\end{itemize}

Other people have also collaborated in the development of Unison:
%
\begin{itemize}
\item Özgür Akgün
\item Mikael Almgren
\item Noric Couderc
\item Frej Drejhammar
\item Erik Ekström
\item Bevin Hansson
\item Jan Tomljanović
\item Kim-Anh Tran
\end{itemize}

\chapter{Getting Started}%
\label{sec:getting-started}

\chapter{LLVM Integration}%
\label{sec:llvm-integration}

\part{Developing and Extending Unison}
\label{part:developing-and-extending-unison}

\chapter{Architecture}%
\label{sec:architecture}

As usual in compiler construction, Unison is organized as a chain of
transformation components through which the program flows.
%
Each intermediate representation of the program is stored in a file.

Figure~\ref{fig:components} shows the main components involved in compilation of
intermediate code to assembly code.
%
Arcs between components are labeled with the file extension corresponding to the
shared data file.
%
The Unison components are enclosed by a dashed rectangle.

\begin{figure}[H]
  \centering
  \scalebox{0.65}{\input{figures/unison-components}}
  \caption{main components and boundaries of Unison}
  \label{fig:components}
\end{figure}

The function of each component is:

\begin{description}

\item [\code{uni import}:] transform the instruction-selected program into
  Unison IR;

\item [\code{uni linearize}:] transform the program to Linear Static Single
  Assignment form;

\item [\code{uni extend}:] extend the program with copies;

\item [\code{uni augment}:] augment the program with alternative temporaries;

\item [\code{uni model}:] formulate a combinatorial problem combining global
  register allocation and instruction scheduling;

\item [\code{gecode-presolver}:] produce an equivalent combinatorial problem
  that is easier to solve;

\item [\code{gecode-solver}:] solve the combinatorial problem;

\item [\code{uni export}:] generate the assembly program with the solution to
  the combinatorial problem.

\end{description}

\chapter{Unison IR}
\label{sec:unison-ir}

\chapter{Constraint Model}\label{sec:constraint-model}

\section{Parameters}\label{sec:parameters}

\boolfalse{showJson}

\subsection{Program}

\input{program-parameters}

\subsection{Processor}

\input{processor-parameters}

\subsection{Objective}

\input{objective-parameters}

\section{Variables}

\input{model-variables}

\section{Constraints}

\input{constraints}

\subsection{Register allocation}

\constraintComment{connected operands}{operands cannot be connected to null temporaries}
\connectedOperandEquation
\constraintComment{connected users}{a temporary is live iff it is connected to a user}
\connectedUsersEquation
where
\usersEquation
\constraintComment{connected definers}{a temporary is live iff it is connected to its definer}
\connectedDefinerEquation
where
\definerEquation
\constraintComment{local operand connections}{local operands are connected iff their operations are active}
\localOperandConnectionEquation
where
\globalEquation
and
\operandOperationEquation
\constraintComment{global operand connections}{global operands are connected iff any of their successors is connected}
\globalOperandConnectionEquation
\constraintComment{active instructions}{active operations are implemented by non-null instructions}
\activeInstructionEquation
\constraintComment{register class}{The instruction that implements an
  operation determines the register class to which its operands are allocated}
\registerClassEquation
\constraintComment{disjoint live ranges}{temporaries whose live ranges overlap are assigned to different register atoms}
\disjointLiveRangesEquation
where
\blockTemporariesEquation
\constraintComment{preassignment}{certain operands are preassigned to registers}
\preAssignmentEquation
\constraintComment{congruence}{connected adjacent operands are assigned to the same register}
\congruenceEquation
\constraintComment{alignment}{aligned operands are assigned to registers at a
  given relative distance}
\alignmentEquation
\constraintComment{packing}{\emph{bound} operands are packed together
  with \emph{free} operands assigned to pack register classes}
\packingEquation


\subsection{Instruction Scheduling}

\constraintComment{live start}{the live range of a temporary starts at the issue cycle of its definer}
\liveStartEquation
\constraintComment{live end}{the live range of a temporary ends with the last issue cycle of its users}
\liveEndEquation
\constraintComment{data precedences}{an operation that uses a temporary must be preceded by its definer}
\dataPrecedencesEquation
\constraintComment{processor resources}{the capacity of each processor resource cannot be exceeded at any issue cycle}
\processorResourcesEquation
where
\blockOperationsEquation
\constraintComment{fixed precedences}{control and read-write dependencies yield fixed precedences among operations}
\fixedPrecedencesEquation
\constraintComment{activation}{an operation is active if any of its activator instructions is selected}
\activationEquation

\section{Objective}

The objective is to minimize the sum of the weighted costs of each block:
%
\genericObjectiveEquation
%
where $\blockWeight{b}$ and $\blockCost{b}$ give the weight and estimated cost
of block $b$.
%
To optimize for speed, $\blockWeight{b}$ is set to $\blockFrequency{b}$
(corresponding to $\optimizeDynamic{} = \code{true}$), and $\blockCost{b}$ is
defined as $\max_{o \in \operations{b} \suchThat
  \activeOperation{o}}{\operationIssueCycle{o}}$ (or simply as
$\operationIssueCycle{\operator{out}(b)}$ where $\operator{out}(b)$ is the
out-delimiter of block $b$).
%
To optimize for code size, $\blockWeight{b}$ is disregarded (corresponding to
$\optimizeDynamic{} = \code{false}$) and $\blockCost{b}$ is defined as $\sum_{o
  \in \operations{b}}{\units{\operationInstruction{o}}{\bits{}}}$, where the
processor resource $\bits{}$ represents the bits with which instructions are
encoded (the particular resource to be optimized for is determined by the
parameter $\optimizeResource{}$).

\chapter{Target Description}
\label{sec:target-description}

\appendix

\chapter{Further Reading}
\label{sec:further-reading}

\end{document}
