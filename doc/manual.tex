\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{abstract}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
\usepackage[breaklinks]{hyperref}
\usepackage{url}
\usepackage{etoolbox}
\usepackage{amsmath}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{positioning, fit}
\usepackage{unison}
\usepackage[left=3cm, right=3cm]{geometry}
\usepackage[adobe-utopia]{mathdesign}

\setcounter{secnumdepth}{2}

\title{The Unison Manual}

\author{Roberto Castañeda Lozano}

\date{}

\renewcommand{\abstractname}{}
\renewcommand{\absnamepos}{empty}

\begin{document}

\maketitle

\setcounter{tocdepth}{2}
\tableofcontents

\section{Introduction}

\section{Getting Started}

\section{LLVM Integration}

\section{Architecture}\label{sec:architecture}

As usual in compiler construction, Unison is organized as a chain of
transformation components through which the program flows.
%
Each intermediate representation of the program is stored in a file.

Figure~\ref{fig:components} shows the main components involved in compilation of
intermediate code to assembly code.
%
Arcs between components are labeled with the file extension corresponding to the
shared data file.
%
The Unison components are enclosed by a dashed rectangle.

\begin{figure}[H]
  \centering
  \scalebox{0.65}{\input{figures/unison-components}}
  \caption{main components and boundaries of Unison}
  \label{fig:components}
\end{figure}

The function of each component is:

\begin{description}

\item [\code{uni import}:] transform the instruction-selected program into
  Unison IR;

\item [\code{uni linearize}:] transform the program to Linear Static Single
  Assignment form;

\item [\code{uni extend}:] extend the program with copies;

\item [\code{uni augment}:] augment the program with alternative temporaries;

\item [\code{uni model}:] formulate a combinatorial problem combining global
  register allocation and instruction scheduling;

\item [\code{gecode-presolver}:] produce an equivalent combinatorial problem
  that is easier to solve;

\item [\code{gecode-solver}:] solve the combinatorial problem;

\item [\code{uni export}:] generate the assembly program with the solution to
  the combinatorial problem.

\end{description}

\section{Unison IR}

\section{Constraint Model}\label{sec:constraint-model}

\subsection{Parameters}\label{sec:parameters}

\boolfalse{showJson}

\subsubsection{Program}

\input{program-parameters}

\subsubsection{Processor}

\input{processor-parameters}

\subsubsection{Objective}

\input{objective-parameters}

\subsection{Variables}

\input{model-variables}

\subsection{Constraints}

\input{constraints}

\subsubsection{Register allocation}

\constraintComment{connected operands}{operands cannot be connected to null temporaries}
\connectedOperandEquation
\constraintComment{connected users}{a temporary is live iff it is connected to a user}
\connectedUsersEquation
where
\usersEquation
\constraintComment{connected definers}{a temporary is live iff it is connected to its definer}
\connectedDefinerEquation
where
\definerEquation
\constraintComment{local operand connections}{local operands are connected iff their operations are active}
\localOperandConnectionEquation
where
\globalEquation
and
\operandOperationEquation
\constraintComment{global operand connections}{global operands are connected iff any of their successors is connected}
\globalOperandConnectionEquation
\constraintComment{active instructions}{active operations are implemented by non-null instructions}
\activeInstructionEquation
\constraintComment{register class}{The instruction that implements an
  operation determines the register class to which its operands are allocated}
\registerClassEquation
\constraintComment{disjoint live ranges}{temporaries whose live ranges overlap are assigned to different register atoms}
\disjointLiveRangesEquation
where
\blockTemporariesEquation
\constraintComment{preassignment}{certain operands are preassigned to registers}
\preAssignmentEquation
\constraintComment{congruence}{connected adjacent operands are assigned to the same register}
\congruenceEquation
\constraintComment{alignment}{aligned operands are assigned to registers at a
  given relative distance}
\alignmentEquation
\constraintComment{packing}{\emph{bound} operands are packed together
  with \emph{free} operands assigned to pack register classes}
\packingEquation


\subsubsection{Instruction Scheduling}

\constraintComment{live start}{the live range of a temporary starts at the issue cycle of its definer}
\liveStartEquation
\constraintComment{live end}{the live range of a temporary ends with the last issue cycle of its users}
\liveEndEquation
\constraintComment{data precedences}{an operation that uses a temporary must be preceded by its definer}
\dataPrecedencesEquation
\constraintComment{processor resources}{the capacity of each processor resource cannot be exceeded at any issue cycle}
\processorResourcesEquation
where
\blockOperationsEquation
\constraintComment{fixed precedences}{control and read-write dependencies yield fixed precedences among operations}
\fixedPrecedencesEquation
\constraintComment{activation}{an operation is active if any of its activator instructions is selected}
\activationEquation

\subsection{Objective}

The objective is to minimize the sum of the weigthed costs of each block:
%
\genericObjectiveEquation
%
where $\blockWeight{b}$ and $\blockCost{b}$ give the weight and estimated cost
of block $b$.
%
To optimize for speed, $\blockWeight{b}$ is set to $\blockFrequency{b}$
(corresponding to $\optimizeDynamic{} = \code{true}$), and $\blockCost{b}$ is
defined as $\max_{o \in \operations{b} \suchThat
  \activeOperation{o}}{\operationIssueCycle{o}}$ (or simply as
$\operationIssueCycle{\operator{out}(b)}$ where $\operator{out}(b)$ is the
out-delimiter of block $b$).
%
To optimize for code size, $\blockWeight{b}$ is disregarded (corresponding to
$\optimizeDynamic{} = \code{false}$) and $\blockCost{b}$ is defined as $\sum_{o
  \in \operations{b}}{\units{\operationInstruction{o}}{\bits{}}}$, where the
processor resource $\bits{}$ represents the bits with which instructions are
encoded (the particular resource to be optimized for is determined by the
parameter $\optimizeResource{}$).

\section{Target Description}

\end{document}
