{-|
Copyright   :  Copyright (c) 2016, SICS Swedish ICT AB
License     :  BSD3 (see the LICENSE file)
Maintainer  :  rcas@sics.se
-}
{-
Main authors:
  Roberto Castaneda Lozano <rcas@sics.se>

This file is part of Unison, see http://unison-code.github.io
-}
{-# LANGUAGE DeriveDataTypeable, RecordWildCards #-}
module SpecsGen.Driver (runSpecsGen) where

import System.FilePath
import System.Console.CmdArgs
import Data.Yaml
import qualified Data.ByteString.Char8 as B8
import Language.Haskell.Pretty
import Data.Maybe

import SpecsGen.SimpleYaml
import SpecsGen.HsGen
import SpecsGen.OperandInfoGen
import SpecsGen.AlignedPairsGen
import SpecsGen.InstructionDeclGen
import SpecsGen.ReadOpGen
import SpecsGen.ShowInstanceGen
import SpecsGen.ReadWriteInfoGen
import SpecsGen.ItineraryGen
import SpecsGen.SizeGen
import SpecsGen.InstructionTypeGen
import SpecsGen.AllInstructionsGen
import SpecsGen.ItineraryDeclGen
import SpecsGen.ParentGen

data SpecsGen =
    SpecsGen {files :: [FilePath], targetName :: String, outputDir :: String,
              constantExtend :: Bool, infiniteRegClass :: [String],
              abstractRegClass :: [String], promoteEffect :: [String],
              regClass :: [String]}
    deriving (Data, Typeable, Show)

specsgen = cmdArgsMode $ SpecsGen
           {
             files = def &= args &= typ "FILES",
             targetName = "",
             outputDir = "" &= typFile,
             constantExtend = False,
             infiniteRegClass = [],
             abstractRegClass = [],
             promoteEffect = [],
             regClass = []
           }
    &= summary "Generates partial Haskell files (.hs) with target information from the given YAML description (.yaml)\nRoberto Castaneda Lozano rcas@sics.se"

runSpecsGen =
    do SpecsGen{..} <- cmdArgsRun specsgen
       yaml         <- mapM readFile files

       let is   = concatMap yamlInstructions yaml
           is1  = expand is
           is2  = is1 ++
                  if constantExtend then mapMaybe constantExtendedOperation is1
                  else []
           is3 = map (promote promoteEffect) is2
           is4 = map (update regClass) is3
           abstractRegClass' = abstractRegClass ++ ["Unknown"]
       writeHsFile outputDir "OperandInfo"
         (emitOperandInfo targetName (infiniteRegClass, abstractRegClass') is4)
       writeHsFile outputDir "AlignedPairs" (emitAlignedPairs targetName is4)
       writeHsFile outputDir (targetName ++ "InstructionDecl") (emitInstructionDecl targetName is4)
       writeHsFile outputDir "ReadOp" (emitReadOp targetName is4)
       writeHsFile outputDir "ShowInstance" (emitShowInstance targetName is4)
       writeHsFile outputDir "ReadWriteInfo" (emitReadWriteInfo targetName is4)
       writeHsFile outputDir "Itinerary" (emitItinerary targetName is4)
       writeHsFile outputDir "Size" (emitSize targetName is4)
       writeHsFile outputDir "InstructionType" (emitInstructionType targetName is4)
       writeHsFile outputDir "AllInstructions" (emitAllInstructions targetName is4)
       writeHsFile outputDir (targetName ++ "ItineraryDecl") (emitItineraryDecl targetName is4)
       writeHsFile outputDir "Parent" (emitParent targetName is4)

writeHsFile dir base f =
    writeFile (dir </> addExtension base ".hs")
    (topComment ++ concatMap (\d -> prettyPrint d ++ "\n\n") f)

yamlInstructions = yInstructions . simplify . decodeYaml

topComment = "-- This file has been generated by specsgen. Do not modify by hand!\n\n"

decodeYaml :: String -> Value
decodeYaml s =
  case decodeEither $ B8.pack s of
    (Left err) -> error err
    Right yaml -> yaml
